{"remainingRequest":"/home/agile/Hairfolio_website/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/agile/Hairfolio_website/node_modules/ng5-slider/esm5/ng5-slider.js","dependencies":[{"path":"/home/agile/Hairfolio_website/node_modules/ng5-slider/esm5/ng5-slider.js","mtime":499162500000},{"path":"/home/agile/Hairfolio_website/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/agile/Hairfolio_website/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { __values, __extends } from 'tslib';\nimport { ElementRef, Renderer2, Component, Directive, ViewChild, HostBinding, HostListener, Input, EventEmitter, Output, ContentChild, ChangeDetectorRef, forwardRef, NgModule } from '@angular/core';\nimport detectPassiveEvents from 'detect-passive-events';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nvar PointerType = {\n    Min: 0,\n    Max: 1,\n};\nPointerType[PointerType.Min] = \"Min\";\nPointerType[PointerType.Max] = \"Max\";\nvar LabelType = {\n    Low: 0,\n    High: 1,\n    Floor: 2,\n    Ceil: 3,\n    TickValue: 4,\n};\nLabelType[LabelType.Low] = \"Low\";\nLabelType[LabelType.High] = \"High\";\nLabelType[LabelType.Floor] = \"Floor\";\nLabelType[LabelType.Ceil] = \"Ceil\";\nLabelType[LabelType.TickValue] = \"TickValue\";\nvar Options = /*@__PURE__*/ (function () {\n    function Options() {\n        this.floor = 0;\n        this.ceil = null;\n        this.step = 1;\n        this.minRange = null;\n        this.maxRange = null;\n        this.pushRange = false;\n        this.minLimit = null;\n        this.maxLimit = null;\n        this.translate = null;\n        this.combineLabels = null;\n        this.getLegend = null;\n        this.stepsArray = null;\n        this.bindIndexForStepsArray = false;\n        this.draggableRange = false;\n        this.draggableRangeOnly = false;\n        this.showSelectionBar = false;\n        this.showSelectionBarEnd = false;\n        this.showSelectionBarFromValue = null;\n        this.showOuterSelectionBars = false;\n        this.hidePointerLabels = false;\n        this.hideLimitLabels = false;\n        this.autoHideLimitLabels = true;\n        this.readOnly = false;\n        this.disabled = false;\n        this.interval = 350;\n        this.showTicks = false;\n        this.showTicksValues = false;\n        this.tickStep = null;\n        this.tickValueStep = 1;\n        this.ticksArray = null;\n        this.ticksTooltip = null;\n        this.ticksValuesTooltip = null;\n        this.vertical = false;\n        this.getSelectionBarColor = null;\n        this.getTickColor = null;\n        this.getPointerColor = null;\n        this.keyboardSupport = true;\n        this.scale = 1;\n        this.enforceStep = true;\n        this.enforceRange = false;\n        this.noSwitching = false;\n        this.onlyBindHandles = false;\n        this.rightToLeft = false;\n        this.reversedControls = false;\n        this.boundPointerLabels = true;\n        this.logScale = false;\n        this.customValueToPosition = null;\n        this.customPositionToValue = null;\n        this.precisionLimit = 12;\n        this.selectionBarGradient = null;\n        this.ariaLabel = null;\n        this.ariaLabelledBy = null;\n        this.ariaLabelHigh = null;\n        this.ariaLabelledByHigh = null;\n        this.handleDimension = null;\n        this.barDimension = null;\n    }\n    return Options;\n}());\nvar ChangeContext = /*@__PURE__*/ (function () {\n    function ChangeContext() {\n    }\n    return ChangeContext;\n}());\nvar ValueHelper = /*@__PURE__*/ (function () {\n    function ValueHelper() {\n    }\n    ValueHelper.linearValueToPosition = function (val, minVal, maxVal) {\n        var range = maxVal - minVal;\n        return (val - minVal) / range;\n    };\n    ValueHelper.logValueToPosition = function (val, minVal, maxVal) {\n        val = Math.log(val);\n        minVal = Math.log(minVal);\n        maxVal = Math.log(maxVal);\n        var range = maxVal - minVal;\n        return (val - minVal) / range;\n    };\n    ValueHelper.linearPositionToValue = function (percent, minVal, maxVal) {\n        return percent * (maxVal - minVal) + minVal;\n    };\n    ValueHelper.logPositionToValue = function (percent, minVal, maxVal) {\n        minVal = Math.log(minVal);\n        maxVal = Math.log(maxVal);\n        var value = percent * (maxVal - minVal) + minVal;\n        return Math.exp(value);\n    };\n    ValueHelper.findStepIndex = function (modelValue, stepsArray) {\n        var differences = stepsArray.map(function (step) { return Math.abs(modelValue - step.value); });\n        var minDifferenceIndex = 0;\n        for (var index = 0; index < stepsArray.length; index++) {\n            if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n                minDifferenceIndex = index;\n            }\n        }\n        return minDifferenceIndex;\n    };\n    return ValueHelper;\n}());\nvar JqLiteWrapper = /*@__PURE__*/ (function () {\n    function JqLiteWrapper(elemRef, renderer) {\n        this.elemRef = elemRef;\n        this.renderer = renderer;\n        this.eventListeners = {};\n    }\n    JqLiteWrapper.prototype.addClass = function (clazz) {\n        this.renderer.addClass(this.elemRef.nativeElement, clazz);\n    };\n    JqLiteWrapper.prototype.removeClass = function (clazz) {\n        this.renderer.removeClass(this.elemRef.nativeElement, clazz);\n    };\n    JqLiteWrapper.prototype.hasClass = function (clazz) {\n        return this.elemRef.nativeElement.classList.contains(clazz);\n    };\n    JqLiteWrapper.prototype.html = function (html) {\n        this.elemRef.nativeElement.innerHTML = html;\n    };\n    JqLiteWrapper.prototype.css = function (style, value) {\n        if (value !== '') {\n            this.renderer.setStyle(this.elemRef.nativeElement, style, value);\n        }\n        else {\n            this.renderer.removeStyle(this.elemRef.nativeElement, style);\n        }\n    };\n    JqLiteWrapper.prototype.attr = function (attr, value) {\n        if (value !== null) {\n            this.renderer.setAttribute(this.elemRef.nativeElement, attr, value);\n        }\n        else {\n            this.renderer.removeAttribute(this.elemRef.nativeElement, attr);\n        }\n    };\n    JqLiteWrapper.prototype.getBoundingClientRect = function () {\n        return this.elemRef.nativeElement.getBoundingClientRect();\n    };\n    JqLiteWrapper.prototype.focus = function () {\n        this.elemRef.nativeElement.focus();\n    };\n    JqLiteWrapper.prototype.on = function (eventName, callback) {\n        if (!this.eventListeners.hasOwnProperty(eventName)) {\n            this.eventListeners[eventName] = [];\n        }\n        var unsubscribe = this.renderer.listen(this.elemRef.nativeElement, eventName, callback);\n        this.eventListeners[eventName].push(unsubscribe);\n    };\n    JqLiteWrapper.prototype.onPassive = function (eventName, callback) {\n        var _this = this;\n        if (!detectPassiveEvents.hasSupport) {\n            this.on(eventName, callback);\n            return;\n        }\n        if (!this.eventListeners.hasOwnProperty(eventName)) {\n            this.eventListeners[eventName] = [];\n        }\n        this.elemRef.nativeElement.addEventListener(eventName, callback, { passive: true, capture: false });\n        var unsubscribe = function () {\n            _this.elemRef.nativeElement.removeEventListener(eventName, callback, { passive: true, capture: false });\n        };\n        this.eventListeners[eventName].push(unsubscribe);\n    };\n    JqLiteWrapper.prototype.off = function (eventName) {\n        if (eventName) {\n            if (this.eventListeners.hasOwnProperty(eventName)) {\n                try {\n                    for (var _a = __values(this.eventListeners[eventName]), _b = _a.next(); !_b.done; _b = _a.next()) {\n                        var unsubscribe = _b.value;\n                        unsubscribe();\n                    }\n                }\n                catch (e_1_1) {\n                    e_1 = { error: e_1_1 };\n                }\n                finally {\n                    try {\n                        if (_b && !_b.done && (_c = _a.return))\n                            _c.call(_a);\n                    }\n                    finally {\n                        if (e_1)\n                            throw e_1.error;\n                    }\n                }\n                delete this.eventListeners[eventName];\n            }\n        }\n        else {\n            try {\n                for (var _d = __values(Object.keys(this.eventListeners)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var eName = _e.value;\n                    this.off(eName);\n                }\n            }\n            catch (e_2_1) {\n                e_2 = { error: e_2_1 };\n            }\n            finally {\n                try {\n                    if (_e && !_e.done && (_f = _d.return))\n                        _f.call(_d);\n                }\n                finally {\n                    if (e_2)\n                        throw e_2.error;\n                }\n            }\n        }\n        var e_1, _c, e_2, _f;\n    };\n    return JqLiteWrapper;\n}());\nvar ThrottledFunc = /*@__PURE__*/ (function () {\n    function ThrottledFunc(func, wait) {\n        this.previous = 0;\n        this.timeout = null;\n        this.func = func;\n        this.wait = wait;\n    }\n    ThrottledFunc.prototype.call = function () {\n        var _this = this;\n        var now = this.getTime();\n        var remaining = this.wait - (now - this.previous);\n        if (remaining <= 0) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n            this.previous = now;\n            this.func();\n        }\n        else if (this.timeout === null) {\n            this.timeout = setTimeout(function () { return _this.callLater(); }, remaining);\n        }\n    };\n    ThrottledFunc.prototype.getTime = function () {\n        return Date.now();\n    };\n    ThrottledFunc.prototype.callLater = function () {\n        this.previous = this.getTime();\n        this.timeout = null;\n        this.func();\n    };\n    return ThrottledFunc;\n}());\nvar CompatibilityHelper = /*@__PURE__*/ (function () {\n    function CompatibilityHelper() {\n    }\n    CompatibilityHelper.isTouchEvent = function (event) {\n        if (((window)).TouchEvent !== undefined) {\n            return event instanceof TouchEvent;\n        }\n        return event.touches !== undefined;\n    };\n    return CompatibilityHelper;\n}());\nvar MathHelper = /*@__PURE__*/ (function () {\n    function MathHelper() {\n    }\n    MathHelper.roundToPrecisionLimit = function (value, precisionLimit) {\n        return +(value.toPrecision(precisionLimit));\n    };\n    MathHelper.clampToRange = function (value, floor, ceil) {\n        return Math.min(Math.max(value, floor), ceil);\n    };\n    return MathHelper;\n}());\nvar Tick = /*@__PURE__*/ (function () {\n    function Tick() {\n    }\n    return Tick;\n}());\nvar Dragging = /*@__PURE__*/ (function () {\n    function Dragging() {\n        this.active = false;\n        this.value = 0;\n        this.difference = 0;\n        this.position = 0;\n        this.lowLimit = 0;\n        this.highLimit = 0;\n    }\n    return Dragging;\n}());\nvar HandleType = {\n    Low: 0,\n    High: 1,\n};\nHandleType[HandleType.Low] = \"Low\";\nHandleType[HandleType.High] = \"High\";\nvar HandleLabelType = {\n    Min: 0,\n    Max: 1,\n};\nHandleLabelType[HandleLabelType.Min] = \"Min\";\nHandleLabelType[HandleLabelType.Max] = \"Max\";\nvar SliderElement = /*@__PURE__*/ (function (_super) {\n    __extends(SliderElement, _super);\n    function SliderElement(elemRef, renderer) {\n        var _this = _super.call(this, elemRef, renderer) || this;\n        _this.position = 0;\n        _this.alwaysHide = false;\n        return _this;\n    }\n    return SliderElement;\n}(JqLiteWrapper));\nvar RightOutSelDirective = /*@__PURE__*/ (function (_super) {\n    __extends(RightOutSelDirective, _super);\n    function RightOutSelDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return RightOutSelDirective;\n}(SliderElement));\nvar LeftOutSelDirective = /*@__PURE__*/ (function (_super) {\n    __extends(LeftOutSelDirective, _super);\n    function LeftOutSelDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return LeftOutSelDirective;\n}(SliderElement));\nvar FullBarDirective = /*@__PURE__*/ (function (_super) {\n    __extends(FullBarDirective, _super);\n    function FullBarDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return FullBarDirective;\n}(SliderElement));\nvar SelBarDirective = /*@__PURE__*/ (function (_super) {\n    __extends(SelBarDirective, _super);\n    function SelBarDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return SelBarDirective;\n}(SliderElement));\nvar MinHDirective = /*@__PURE__*/ (function (_super) {\n    __extends(MinHDirective, _super);\n    function MinHDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return MinHDirective;\n}(SliderElement));\nvar MaxHDirective = /*@__PURE__*/ (function (_super) {\n    __extends(MaxHDirective, _super);\n    function MaxHDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return MaxHDirective;\n}(SliderElement));\nvar FlrLabDirective = /*@__PURE__*/ (function (_super) {\n    __extends(FlrLabDirective, _super);\n    function FlrLabDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return FlrLabDirective;\n}(SliderElement));\nvar CeilLabDirective = /*@__PURE__*/ (function (_super) {\n    __extends(CeilLabDirective, _super);\n    function CeilLabDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return CeilLabDirective;\n}(SliderElement));\nvar MinLabDirective = /*@__PURE__*/ (function (_super) {\n    __extends(MinLabDirective, _super);\n    function MinLabDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return MinLabDirective;\n}(SliderElement));\nvar MaxLabDirective = /*@__PURE__*/ (function (_super) {\n    __extends(MaxLabDirective, _super);\n    function MaxLabDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return MaxLabDirective;\n}(SliderElement));\nvar CmbLabDirective = /*@__PURE__*/ (function (_super) {\n    __extends(CmbLabDirective, _super);\n    function CmbLabDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return CmbLabDirective;\n}(SliderElement));\nvar TicksDirective = /*@__PURE__*/ (function (_super) {\n    __extends(TicksDirective, _super);\n    function TicksDirective(elemRef, renderer) {\n        return _super.call(this, elemRef, renderer) || this;\n    }\n    return TicksDirective;\n}(SliderElement));\nvar NG5_SLIDER_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return SliderComponent; }),\n    multi: true,\n};\nvar SliderComponent = /*@__PURE__*/ (function () {\n    function SliderComponent(renderer, elementRef, changeDetectionRef) {\n        this.renderer = renderer;\n        this.elementRef = elementRef;\n        this.changeDetectionRef = changeDetectionRef;\n        this.valueChange = new EventEmitter();\n        this.highValueChange = new EventEmitter();\n        this.userChangeStart = new EventEmitter();\n        this.userChange = new EventEmitter();\n        this.userChangeEnd = new EventEmitter();\n        this._options = new Options();\n        this.viewOptions = new Options();\n        this.barStyle = {};\n        this.minPointerStyle = {};\n        this.maxPointerStyle = {};\n        this.showTicks = false;\n        this.ticks = [];\n        this.sliderElementVerticalClass = false;\n        this.sliderElementDisabledAttr = null;\n        this.dragging = new Dragging();\n        this.handleHalfDim = 0;\n        this.maxPos = 0;\n        this.precisionLimit = 12;\n        this.step = 1;\n        this.tracking = null;\n        this.minValue = 0;\n        this.maxValue = 0;\n        this.valueRange = 0;\n        this.intermediateTicks = false;\n        this.initHasRun = false;\n        this.firstKeyDown = false;\n        this.cmbLabelShown = false;\n        this.currentFocusElement = null;\n        this.onMoveUnsubscribe = null;\n        this.onEndUnsubscribe = null;\n        this.onTouchedCallback = null;\n        this.onChangeCallback = null;\n    }\n    Object.defineProperty(SliderComponent.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (newValue) {\n            this._value = +newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"highValue\", {\n        get: function () {\n            return this._highValue;\n        },\n        set: function (newHighValue) {\n            this._highValue = +newHighValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"options\", {\n        get: function () {\n            return this._options;\n        },\n        set: function (newOptions) {\n            this._options = newOptions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"manualRefresh\", {\n        set: function (manualRefresh) {\n            var _this = this;\n            this.unsubscribeManualRefresh();\n            this.manualRefreshSubscription = manualRefresh.subscribe(function () {\n                setTimeout(function () { return _this.calcViewDimensions(); });\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SliderComponent.prototype, \"range\", {\n        get: function () {\n            return this.value !== undefined && this.highValue !== undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SliderComponent.prototype.ngOnInit = function () {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options);\n        this.setDisabledStateAttr();\n        this.setVerticalClass();\n    };\n    SliderComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.thrOnLowHandleChange = new ThrottledFunc(function () { _this.onLowHandleChange(); }, this.viewOptions.interval);\n        this.thrOnHighHandleChange = new ThrottledFunc(function () { _this.onHighHandleChange(); }, this.viewOptions.interval);\n        this.applyOptions();\n        this.syncLowValue();\n        if (this.range) {\n            this.syncHighValue();\n        }\n        this.manageElementsStyle();\n        this.setDisabledStateAttr();\n        this.calcViewDimensions();\n        this.setMinAndMax();\n        this.addAccessibility();\n        this.updateCeilLab();\n        this.updateFloorLab();\n        this.initHandles();\n        this.manageEventsBindings();\n        this.initHasRun = true;\n        if (this.value !== this.viewLowValue || (this.range && this.highValue !== this.viewHighValue)) {\n            setTimeout(function () { return _this.applyModel(false); });\n        }\n        this.changeDetectionRef.detectChanges();\n    };\n    SliderComponent.prototype.ngOnChanges = function (changes) {\n        if (changes[\"options\"]) {\n            this.onChangeOptions(changes[\"options\"].previousValue, changes[\"options\"].currentValue);\n        }\n        if (changes[\"value\"]) {\n            this.onChangeValue(changes[\"value\"].previousValue, changes[\"value\"].currentValue);\n        }\n        if (changes[\"highValue\"]) {\n            this.onChangeHighValue(changes[\"highValue\"].previousValue, changes[\"highValue\"].currentValue);\n        }\n    };\n    SliderComponent.prototype.onChangeOptions = function (oldValue, newValue) {\n        if (!this.initHasRun || newValue === oldValue) {\n            return;\n        }\n        this.applyOptions();\n        this.syncLowValue();\n        if (this.range) {\n            this.syncHighValue();\n        }\n        this.resetSlider();\n    };\n    SliderComponent.prototype.onChangeValue = function (oldValue, newValue) {\n        if (!this.initHasRun || newValue === oldValue) {\n            return;\n        }\n        this.thrOnLowHandleChange.call();\n    };\n    SliderComponent.prototype.onChangeHighValue = function (oldValue, newValue) {\n        if (!this.initHasRun || newValue === oldValue) {\n            return;\n        }\n        if (newValue != null) {\n            this.thrOnHighHandleChange.call();\n        }\n        if ((this.range && newValue == null) ||\n            (!this.range && newValue != null)) {\n            this.applyOptions();\n            this.resetSlider();\n        }\n    };\n    SliderComponent.prototype.onResize = function (event) {\n        this.calcViewDimensions();\n    };\n    SliderComponent.prototype.ngOnDestroy = function () {\n        this.unsubscribeManualRefresh();\n        this.unbindEvents();\n        this.currentFocusElement = null;\n    };\n    SliderComponent.prototype.writeValue = function (obj) {\n        if (obj instanceof Array) {\n            var oldValue = this.value;\n            var oldHighValue = this.highValue;\n            this.value = obj[0];\n            this.highValue = obj[1];\n            this.onChangeValue(oldValue, this.value);\n            this.onChangeHighValue(oldHighValue, this.highValue);\n        }\n        else {\n            var oldValue = this.value;\n            this.value = obj;\n            this.onChangeValue(oldValue, this.value);\n        }\n    };\n    SliderComponent.prototype.registerOnChange = function (onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n    };\n    SliderComponent.prototype.registerOnTouched = function (onTouchedCallback) {\n        this.onTouchedCallback = onTouchedCallback;\n    };\n    SliderComponent.prototype.setDisabledState = function (isDisabled) {\n        if (this.viewOptions) {\n            this.viewOptions.disabled = isDisabled;\n            this.setDisabledStateAttr();\n        }\n    };\n    SliderComponent.prototype.unsubscribeManualRefresh = function () {\n        if (this.manualRefreshSubscription) {\n            this.manualRefreshSubscription.unsubscribe();\n            this.manualRefreshSubscription = null;\n        }\n    };\n    SliderComponent.prototype.getCurrentTrackingValue = function () {\n        if (this.tracking === null) {\n            return null;\n        }\n        return this.tracking === HandleType.Low ? this.viewLowValue : this.viewHighValue;\n    };\n    SliderComponent.prototype.syncLowValue = function () {\n        if (this.viewOptions.stepsArray) {\n            if (!this.viewOptions.bindIndexForStepsArray) {\n                this.viewLowValue = ValueHelper.findStepIndex(this.value, this.viewOptions.stepsArray);\n            }\n            else {\n                this.viewLowValue = this.value;\n            }\n        }\n        else {\n            this.viewLowValue = this.value;\n        }\n    };\n    SliderComponent.prototype.syncHighValue = function () {\n        if (this.viewOptions.stepsArray) {\n            if (!this.viewOptions.bindIndexForStepsArray) {\n                this.viewHighValue = ValueHelper.findStepIndex(this.highValue, this.viewOptions.stepsArray);\n            }\n            else {\n                this.viewHighValue = this.highValue;\n            }\n        }\n        else {\n            this.viewHighValue = this.highValue;\n        }\n    };\n    SliderComponent.prototype.getStepValue = function (sliderValue) {\n        var step = this.viewOptions.stepsArray[sliderValue];\n        return step.value;\n    };\n    SliderComponent.prototype.applyLowValue = function () {\n        if (this.viewOptions.stepsArray) {\n            if (!this.viewOptions.bindIndexForStepsArray) {\n                this.value = this.getStepValue(this.viewLowValue);\n            }\n            else {\n                this.value = this.viewLowValue;\n            }\n        }\n        else {\n            this.value = this.viewLowValue;\n        }\n    };\n    SliderComponent.prototype.applyHighValue = function () {\n        if (this.viewOptions.stepsArray) {\n            if (!this.viewOptions.bindIndexForStepsArray) {\n                this.highValue = this.getStepValue(this.viewHighValue);\n            }\n            else {\n                this.highValue = this.viewHighValue;\n            }\n        }\n        else {\n            this.highValue = this.viewHighValue;\n        }\n    };\n    SliderComponent.prototype.onLowHandleChange = function () {\n        this.normaliseLowValue();\n        if (this.range) {\n            this.normaliseRange(PointerType.Min);\n        }\n        this.syncLowValue();\n        if (this.range) {\n            this.syncHighValue();\n        }\n        this.setMinAndMax();\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        this.updateAriaAttributes();\n        if (this.range) {\n            this.updateCmbLabel();\n        }\n    };\n    SliderComponent.prototype.onHighHandleChange = function () {\n        this.normaliseHighValue();\n        this.normaliseRange(PointerType.Max);\n        this.syncLowValue();\n        this.syncHighValue();\n        this.setMinAndMax();\n        this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        this.updateCmbLabel();\n        this.updateAriaAttributes();\n    };\n    SliderComponent.prototype.normaliseLowValue = function () {\n        var _this = this;\n        if (this.viewOptions.stepsArray) {\n            return;\n        }\n        var normalisedValue = MathHelper.clampToRange(this.value, this.viewOptions.floor, this.viewOptions.ceil);\n        if (this.value !== normalisedValue) {\n            this.value = normalisedValue;\n            setTimeout(function () { return _this.applyModel(false); });\n        }\n    };\n    SliderComponent.prototype.normaliseHighValue = function () {\n        var _this = this;\n        if (this.viewOptions.stepsArray) {\n            return;\n        }\n        var normalisedHighValue = MathHelper.clampToRange(this.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n        if (this.highValue !== normalisedHighValue) {\n            this.highValue = normalisedHighValue;\n            setTimeout(function () { return _this.applyModel(false); });\n        }\n    };\n    SliderComponent.prototype.normaliseRange = function (changedPointer) {\n        var _this = this;\n        if (this.viewOptions.stepsArray) {\n            return;\n        }\n        if (this.range && this.value > this.highValue) {\n            if (this.viewOptions.noSwitching) {\n                if (changedPointer === PointerType.Max) {\n                    this.highValue = this.value;\n                }\n                else if (changedPointer === PointerType.Min) {\n                    this.value = this.highValue;\n                }\n                setTimeout(function () { return _this.applyModel(false); });\n            }\n            else {\n                var tempValue = this.value;\n                this.value = this.highValue;\n                this.highValue = tempValue;\n                if (changedPointer === PointerType.Max) {\n                    setTimeout(function () { return _this.thrOnLowHandleChange.call(); });\n                }\n                else if (changedPointer === PointerType.Min) {\n                    setTimeout(function () { return _this.thrOnHighHandleChange.call(); });\n                }\n                setTimeout(function () { return _this.applyModel(false); });\n            }\n        }\n    };\n    SliderComponent.prototype.applyOptions = function () {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options);\n        if (this.viewOptions.precisionLimit) {\n            this.precisionLimit = this.viewOptions.precisionLimit;\n        }\n        if (this.viewOptions.step <= 0) {\n            this.viewOptions.step = 1;\n        }\n        this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n        this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n        if (this.viewOptions.draggableRangeOnly) {\n            this.viewOptions.draggableRange = true;\n        }\n        this.viewOptions.showTicks = this.viewOptions.showTicks ||\n            this.viewOptions.showTicksValues ||\n            !!this.viewOptions.ticksArray;\n        if (this.viewOptions.showTicks && (this.viewOptions.tickStep !== null || this.viewOptions.ticksArray)) {\n            this.intermediateTicks = true;\n        }\n        this.showTicks = this.viewOptions.showTicks;\n        this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar ||\n            this.viewOptions.showSelectionBarEnd ||\n            this.viewOptions.showSelectionBarFromValue !== null;\n        if (this.viewOptions.stepsArray) {\n            this.parseStepsArray();\n        }\n        else {\n            if (this.viewOptions.translate) {\n                this.translate = this.viewOptions.translate;\n            }\n            else {\n                this.translate = function (value) { return String(value); };\n            }\n            this.getLegend = this.viewOptions.getLegend;\n        }\n        if (this.viewOptions.combineLabels) {\n            this.combineLabels = this.viewOptions.combineLabels;\n        }\n        else {\n            this.combineLabels = function (minValue, maxValue) {\n                return minValue + ' - ' + maxValue;\n            };\n        }\n    };\n    SliderComponent.prototype.parseStepsArray = function () {\n        var _this = this;\n        this.viewOptions.floor = 0;\n        this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n        this.viewOptions.step = 1;\n        if (this.viewOptions.translate) {\n            this.translate = this.viewOptions.translate;\n        }\n        else {\n            this.translate = function (modelValue) {\n                if (_this.viewOptions.bindIndexForStepsArray) {\n                    return String(_this.getStepValue(modelValue));\n                }\n                return String(modelValue);\n            };\n        }\n        this.getLegend = function (index) {\n            var step = _this.viewOptions.stepsArray[index];\n            return step.legend;\n        };\n    };\n    SliderComponent.prototype.resetSlider = function () {\n        this.manageElementsStyle();\n        this.addAccessibility();\n        this.setMinAndMax();\n        this.updateCeilLab();\n        this.updateFloorLab();\n        this.unbindEvents();\n        this.manageEventsBindings();\n        this.setDisabledStateAttr();\n        this.calcViewDimensions();\n        this.refocusPointerIfNeeded();\n    };\n    SliderComponent.prototype.refocusPointerIfNeeded = function () {\n        if (this.currentFocusElement) {\n            this.onPointerFocus(this.currentFocusElement.pointer, this.currentFocusElement.ref);\n            this.focusElement(this.currentFocusElement.pointer);\n        }\n    };\n    SliderComponent.prototype.manageElementsStyle = function () {\n        var _this = this;\n        if (!this.range) {\n            this.maxHElem.css('display', 'none');\n        }\n        else {\n            this.maxHElem.css('display', '');\n        }\n        this.alwaysHide(this.flrLabElem, this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        this.alwaysHide(this.ceilLabElem, this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        var hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;\n        this.alwaysHide(this.minLabElem, hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n        this.alwaysHide(this.maxLabElem, hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.alwaysHide(this.cmbLabElem, hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.alwaysHide(this.selBarElem, !this.range && !this.viewOptions.showSelectionBar);\n        this.alwaysHide(this.leftOutSelBar, !this.range || !this.viewOptions.showOuterSelectionBars);\n        this.alwaysHide(this.rightOutSelBar, !this.range || !this.viewOptions.showOuterSelectionBars);\n        if (this.range && this.viewOptions.showOuterSelectionBars) {\n            this.fullBarElem.addClass('ng5-slider-transparent');\n        }\n        if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n            this.setVerticalClass();\n            setTimeout(function () { _this.resetSlider(); });\n        }\n        if (this.viewOptions.draggableRange) {\n            this.selBarElem.addClass('ng5-slider-draggable');\n        }\n        else {\n            this.selBarElem.removeClass('ng5-slider-draggable');\n        }\n        if (this.intermediateTicks && this.options.showTicksValues) {\n            this.ticksElem.addClass('ng5-slider-ticks-values-under');\n        }\n    };\n    SliderComponent.prototype.alwaysHide = function (el, hide) {\n        el.alwaysHide = hide;\n        if (hide) {\n            this.hideEl(el);\n        }\n        else {\n            this.showEl(el);\n        }\n    };\n    SliderComponent.prototype.manageEventsBindings = function () {\n        if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n            this.unbindEvents();\n        }\n        else {\n            this.bindEvents();\n        }\n    };\n    SliderComponent.prototype.setDisabledStateAttr = function () {\n        this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n    };\n    SliderComponent.prototype.setVerticalClass = function () {\n        this.sliderElementVerticalClass = this.viewOptions.vertical;\n    };\n    SliderComponent.prototype.resetLabelsValue = function () {\n        this.minLabElem.value = undefined;\n        this.maxLabElem.value = undefined;\n    };\n    SliderComponent.prototype.initHandles = function () {\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        if (this.range) {\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n        this.updateSelectionBar();\n        if (this.range) {\n            this.updateCmbLabel();\n        }\n        this.updateTicksScale();\n    };\n    SliderComponent.prototype.setLabelValue = function (value, label) {\n        var recalculateDimension = false;\n        var noLabelInjection = label.hasClass('no-label-injection');\n        if (!label.alwaysHide &&\n            (label.value === undefined ||\n                label.value.length !== value.length ||\n                (label.value.length > 0 && label.dimension === 0))) {\n            recalculateDimension = true;\n            label.value = value;\n        }\n        if (!noLabelInjection) {\n            label.html(value);\n        }\n        if (recalculateDimension) {\n            this.calculateElementDimension(label);\n        }\n    };\n    SliderComponent.prototype.setMinAndMax = function () {\n        this.step = +this.viewOptions.step;\n        this.minValue = this.viewOptions.floor;\n        if (this.viewOptions.logScale && this.minValue === 0) {\n            throw Error('Can\\'t use floor=0 with logarithmic scale');\n        }\n        if (this.viewOptions.enforceStep) {\n            this.viewLowValue = this.roundStep(this.viewLowValue);\n            if (this.range) {\n                this.viewHighValue = this.roundStep(this.viewHighValue);\n            }\n        }\n        if (this.viewOptions.ceil != null) {\n            this.maxValue = this.viewOptions.ceil;\n        }\n        else {\n            this.maxValue = this.viewOptions.ceil = this.range ? this.viewHighValue : this.viewLowValue;\n        }\n        if (this.viewOptions.enforceRange) {\n            this.viewLowValue = this.sanitizeValue(this.viewLowValue);\n            if (this.range) {\n                this.viewHighValue = this.sanitizeValue(this.viewHighValue);\n            }\n        }\n        this.applyLowValue();\n        if (this.range) {\n            this.applyHighValue();\n        }\n        this.valueRange = this.maxValue - this.minValue;\n    };\n    SliderComponent.prototype.addAccessibility = function () {\n        this.updateAriaAttributes();\n        this.minHElem.attr('role', 'slider');\n        if (this.viewOptions.keyboardSupport &&\n            !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n            this.minHElem.attr('tabindex', '0');\n        }\n        else {\n            this.minHElem.attr('tabindex', '');\n        }\n        if (this.viewOptions.vertical) {\n            this.minHElem.attr('aria-orientation', 'vertical');\n        }\n        if (this.viewOptions.ariaLabel) {\n            this.minHElem.attr('aria-label', this.viewOptions.ariaLabel);\n        }\n        else if (this.viewOptions.ariaLabelledBy) {\n            this.minHElem.attr('aria-labelledby', this.viewOptions.ariaLabelledBy);\n        }\n        if (this.range) {\n            this.maxHElem.attr('role', 'slider');\n            if (this.viewOptions.keyboardSupport &&\n                !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n                this.maxHElem.attr('tabindex', '0');\n            }\n            else {\n                this.maxHElem.attr('tabindex', '');\n            }\n            if (this.viewOptions.vertical) {\n                this.maxHElem.attr('aria-orientation', 'vertical');\n            }\n            if (this.viewOptions.ariaLabelHigh) {\n                this.maxHElem.attr('aria-label', this.viewOptions.ariaLabelHigh);\n            }\n            else if (this.viewOptions.ariaLabelledByHigh) {\n                this.maxHElem.attr('aria-labelledby', this.viewOptions.ariaLabelledByHigh);\n            }\n        }\n    };\n    SliderComponent.prototype.updateAriaAttributes = function () {\n        this.minHElem.attr('aria-valuenow', this.value.toString());\n        this.minHElem.attr('aria-valuetext', this.translate(this.value, LabelType.Low));\n        this.minHElem.attr('aria-valuemin', this.minValue.toString());\n        this.minHElem.attr('aria-valuemax', this.maxValue.toString());\n        if (this.range) {\n            this.maxHElem.attr('aria-valuenow', this.highValue.toString());\n            this.maxHElem.attr('aria-valuetext', this.translate(this.highValue, LabelType.High));\n            this.maxHElem.attr('aria-valuemin', this.minValue.toString());\n            this.maxHElem.attr('aria-valuemax', this.maxValue.toString());\n        }\n    };\n    SliderComponent.prototype.calcViewDimensions = function () {\n        if (this.viewOptions.handleDimension) {\n            this.minHElem.dimension = this.viewOptions.handleDimension;\n        }\n        else {\n            this.calculateElementDimension(this.minHElem);\n        }\n        var handleWidth = this.minHElem.dimension;\n        this.handleHalfDim = handleWidth / 2;\n        if (this.viewOptions.barDimension) {\n            this.fullBarElem.dimension = this.viewOptions.barDimension;\n        }\n        else {\n            this.calculateElementDimension(this.fullBarElem);\n        }\n        this.barDimension = this.fullBarElem.dimension;\n        this.maxPos = this.barDimension - handleWidth;\n        if (this.initHasRun) {\n            this.updateFloorLab();\n            this.updateCeilLab();\n            this.initHandles();\n        }\n    };\n    SliderComponent.prototype.updateTicksScale = function () {\n        var _this = this;\n        if (!this.viewOptions.showTicks) {\n            return;\n        }\n        var ticksArray = this.viewOptions.ticksArray || this.getTicksArray();\n        var translate = this.viewOptions.vertical ? 'translateY' : 'translateX';\n        if (this.viewOptions.rightToLeft) {\n            ticksArray.reverse();\n        }\n        this.ticks = ticksArray.map(function (value) {\n            var position = _this.valueToPosition(value);\n            if (_this.viewOptions.vertical) {\n                position = _this.maxPos - position;\n            }\n            var translation = translate + '(' + Math.round(position) + 'px)';\n            var tick = new Tick();\n            tick.selected = _this.isTickSelected(value);\n            tick.style = {\n                '-webkit-transform': translation,\n                '-moz-transform': translation,\n                '-o-transform': translation,\n                '-ms-transform': translation,\n                transform: translation,\n            };\n            if (tick.selected && _this.viewOptions.getSelectionBarColor) {\n                tick.style['background-color'] = _this.getSelectionBarColor();\n            }\n            if (!tick.selected && _this.viewOptions.getTickColor) {\n                tick.style['background-color'] = _this.getTickColor(value);\n            }\n            if (_this.viewOptions.ticksTooltip) {\n                tick.tooltip = _this.viewOptions.ticksTooltip(value);\n                tick.tooltipPlacement = _this.viewOptions.vertical ? 'right' : 'top';\n            }\n            if (_this.viewOptions.showTicksValues && (value % _this.viewOptions.tickValueStep === 0)) {\n                tick.value = _this.getDisplayValue(value, LabelType.TickValue);\n                if (_this.viewOptions.ticksValuesTooltip) {\n                    tick.valueTooltip = _this.viewOptions.ticksValuesTooltip(value);\n                    tick.valueTooltipPlacement = _this.viewOptions.vertical\n                        ? 'right'\n                        : 'top';\n                }\n            }\n            if (_this.getLegend) {\n                var legend = _this.getLegend(value);\n                if (legend) {\n                    tick.legend = legend;\n                }\n            }\n            return tick;\n        });\n    };\n    SliderComponent.prototype.getTicksArray = function () {\n        var step = (this.viewOptions.tickStep !== null) ? this.viewOptions.tickStep : this.step;\n        var ticksArray = [];\n        for (var value = this.minValue; value <= this.maxValue; value += step) {\n            ticksArray.push(value);\n        }\n        return ticksArray;\n    };\n    SliderComponent.prototype.isTickSelected = function (value) {\n        if (!this.range) {\n            if (this.viewOptions.showSelectionBarFromValue !== null) {\n                var center = this.viewOptions.showSelectionBarFromValue;\n                if (this.viewLowValue > center &&\n                    value >= center &&\n                    value <= this.viewLowValue) {\n                    return true;\n                }\n                else if (this.viewLowValue < center &&\n                    value <= center &&\n                    value >= this.viewLowValue) {\n                    return true;\n                }\n            }\n            else if (this.viewOptions.showSelectionBarEnd) {\n                if (value >= this.viewLowValue) {\n                    return true;\n                }\n            }\n            else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n                return true;\n            }\n        }\n        if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n            return true;\n        }\n        return false;\n    };\n    SliderComponent.prototype.updateFloorLab = function () {\n        if (!this.flrLabElem.alwaysHide) {\n            this.setLabelValue(this.getDisplayValue(this.minValue, LabelType.Floor), this.flrLabElem);\n            this.calculateElementDimension(this.flrLabElem);\n            var position = this.viewOptions.rightToLeft\n                ? this.barDimension - this.flrLabElem.dimension\n                : 0;\n            this.setPosition(this.flrLabElem, position);\n        }\n    };\n    SliderComponent.prototype.updateCeilLab = function () {\n        if (!this.ceilLabElem.alwaysHide) {\n            this.setLabelValue(this.getDisplayValue(this.maxValue, LabelType.Ceil), this.ceilLabElem);\n            this.calculateElementDimension(this.ceilLabElem);\n            var position = this.viewOptions.rightToLeft\n                ? 0\n                : this.barDimension - this.ceilLabElem.dimension;\n            this.setPosition(this.ceilLabElem, position);\n        }\n    };\n    SliderComponent.prototype.updateHandles = function (which, newPos) {\n        if (which === HandleType.Low) {\n            this.updateLowHandle(newPos);\n        }\n        else {\n            this.updateHighHandle(newPos);\n        }\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        if (this.range) {\n            this.updateCmbLabel();\n        }\n    };\n    SliderComponent.prototype.getHandleLabelPos = function (labelType, newPos) {\n        var labelDimension = labelType === HandleLabelType.Min ? this.minLabElem.dimension : this.maxLabElem.dimension;\n        var nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDim;\n        var endOfBarPos = this.barDimension - labelDimension;\n        if (!this.viewOptions.boundPointerLabels) {\n            return nearHandlePos;\n        }\n        if ((this.viewOptions.rightToLeft && labelType === HandleLabelType.Min) ||\n            (!this.viewOptions.rightToLeft && labelType === HandleLabelType.Max)) {\n            return Math.min(nearHandlePos, endOfBarPos);\n        }\n        else {\n            return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n        }\n    };\n    SliderComponent.prototype.updateLowHandle = function (newPos) {\n        this.setPosition(this.minHElem, newPos);\n        this.setLabelValue(this.getDisplayValue(this.viewLowValue, LabelType.Low), this.minLabElem);\n        this.setPosition(this.minLabElem, this.getHandleLabelPos(HandleLabelType.Min, newPos));\n        if (this.viewOptions.getPointerColor) {\n            var pointercolor = this.getPointerColor(PointerType.Min);\n            this.minPointerStyle = {\n                backgroundColor: pointercolor,\n            };\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.shFloorCeil();\n        }\n    };\n    SliderComponent.prototype.updateHighHandle = function (newPos) {\n        this.setPosition(this.maxHElem, newPos);\n        this.setLabelValue(this.getDisplayValue(this.viewHighValue, LabelType.High), this.maxLabElem);\n        this.setPosition(this.maxLabElem, this.getHandleLabelPos(HandleLabelType.Max, newPos));\n        if (this.viewOptions.getPointerColor) {\n            var pointercolor = this.getPointerColor(PointerType.Max);\n            this.maxPointerStyle = {\n                backgroundColor: pointercolor,\n            };\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.shFloorCeil();\n        }\n    };\n    SliderComponent.prototype.shFloorCeil = function () {\n        if (this.viewOptions.hidePointerLabels) {\n            return;\n        }\n        var flHidden = false;\n        var clHidden = false;\n        var isMinLabAtFloor = this.isLabelBelowFloorLab(this.minLabElem);\n        var isMinLabAtCeil = this.isLabelAboveCeilLab(this.minLabElem);\n        var isMaxLabAtCeil = this.isLabelAboveCeilLab(this.maxLabElem);\n        var isCmbLabAtFloor = this.isLabelBelowFloorLab(this.cmbLabElem);\n        var isCmbLabAtCeil = this.isLabelAboveCeilLab(this.cmbLabElem);\n        if (isMinLabAtFloor) {\n            flHidden = true;\n            this.hideEl(this.flrLabElem);\n        }\n        else {\n            flHidden = false;\n            this.showEl(this.flrLabElem);\n        }\n        if (isMinLabAtCeil) {\n            clHidden = true;\n            this.hideEl(this.ceilLabElem);\n        }\n        else {\n            clHidden = false;\n            this.showEl(this.ceilLabElem);\n        }\n        if (this.range) {\n            var hideCeil = this.cmbLabelShown ? isCmbLabAtCeil : isMaxLabAtCeil;\n            var hideFloor = this.cmbLabelShown\n                ? isCmbLabAtFloor\n                : isMinLabAtFloor;\n            if (hideCeil) {\n                this.hideEl(this.ceilLabElem);\n            }\n            else if (!clHidden) {\n                this.showEl(this.ceilLabElem);\n            }\n            if (hideFloor) {\n                this.hideEl(this.flrLabElem);\n            }\n            else if (!flHidden) {\n                this.showEl(this.flrLabElem);\n            }\n        }\n    };\n    SliderComponent.prototype.isLabelBelowFloorLab = function (label) {\n        var isRTL = this.viewOptions.rightToLeft;\n        var pos = label.position;\n        var dim = label.dimension;\n        var floorPos = this.flrLabElem.position;\n        var floorDim = this.flrLabElem.dimension;\n        return isRTL\n            ? pos + dim >= floorPos - 2\n            : pos <= floorPos + floorDim + 2;\n    };\n    SliderComponent.prototype.isLabelAboveCeilLab = function (label) {\n        var isRTL = this.viewOptions.rightToLeft;\n        var pos = label.position;\n        var dim = label.dimension;\n        var ceilPos = this.ceilLabElem.position;\n        var ceilDim = this.ceilLabElem.dimension;\n        return isRTL ? pos <= ceilPos + ceilDim + 2 : pos + dim >= ceilPos - 2;\n    };\n    SliderComponent.prototype.updateSelectionBar = function () {\n        var position = 0;\n        var dimension = 0;\n        var isSelectionBarFromRight = this.viewOptions.rightToLeft\n            ? !this.viewOptions.showSelectionBarEnd\n            : this.viewOptions.showSelectionBarEnd;\n        var positionForRange = this.viewOptions.rightToLeft\n            ? this.maxHElem.position + this.handleHalfDim\n            : this.minHElem.position + this.handleHalfDim;\n        if (this.range) {\n            dimension = Math.abs(this.maxHElem.position - this.minHElem.position);\n            position = positionForRange;\n        }\n        else {\n            if (this.viewOptions.showSelectionBarFromValue !== null) {\n                var center = this.viewOptions.showSelectionBarFromValue;\n                var centerPosition = this.valueToPosition(center);\n                var isModelGreaterThanCenter = this.viewOptions.rightToLeft\n                    ? this.viewLowValue <= center\n                    : this.viewLowValue > center;\n                if (isModelGreaterThanCenter) {\n                    dimension = this.minHElem.position - centerPosition;\n                    position = centerPosition + this.handleHalfDim;\n                }\n                else {\n                    dimension = centerPosition - this.minHElem.position;\n                    position = this.minHElem.position + this.handleHalfDim;\n                }\n            }\n            else if (isSelectionBarFromRight) {\n                dimension = Math.ceil(Math.abs(this.maxPos - this.minHElem.position) + this.handleHalfDim);\n                position = Math.floor(this.minHElem.position + this.handleHalfDim);\n            }\n            else {\n                dimension = this.minHElem.position + this.handleHalfDim;\n                position = 0;\n            }\n        }\n        this.setDimension(this.selBarElem, dimension);\n        this.setPosition(this.selBarElem, position);\n        if (this.range && this.viewOptions.showOuterSelectionBars) {\n            if (this.viewOptions.rightToLeft) {\n                this.setDimension(this.rightOutSelBar, position);\n                this.setPosition(this.rightOutSelBar, 0);\n                this.calculateElementDimension(this.fullBarElem);\n                this.setDimension(this.leftOutSelBar, this.fullBarElem.dimension - (position + dimension));\n                this.setPosition(this.leftOutSelBar, position + dimension);\n            }\n            else {\n                this.setDimension(this.leftOutSelBar, position);\n                this.setPosition(this.leftOutSelBar, 0);\n                this.calculateElementDimension(this.fullBarElem);\n                this.setDimension(this.rightOutSelBar, this.fullBarElem.dimension - (position + dimension));\n                this.setPosition(this.rightOutSelBar, position + dimension);\n            }\n        }\n        if (this.viewOptions.getSelectionBarColor) {\n            var color = this.getSelectionBarColor();\n            this.barStyle = {\n                backgroundColor: color,\n            };\n        }\n        else if (this.viewOptions.selectionBarGradient) {\n            var offset = this.viewOptions.showSelectionBarFromValue !== null\n                ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue)\n                : 0;\n            var reversed = (offset - position > 0 && !isSelectionBarFromRight) || (offset - position <= 0 && isSelectionBarFromRight);\n            var direction = this.viewOptions.vertical\n                ? reversed ? 'bottom' : 'top'\n                : reversed ? 'left' : 'right';\n            this.barStyle = {\n                backgroundImage: 'linear-gradient(to ' +\n                    direction +\n                    ', ' +\n                    this.viewOptions.selectionBarGradient.from +\n                    ' 0%,' +\n                    this.viewOptions.selectionBarGradient.to +\n                    ' 100%)',\n            };\n            if (this.viewOptions.vertical) {\n                this.barStyle.backgroundPosition =\n                    'center ' +\n                        (offset +\n                            dimension +\n                            position +\n                            (reversed ? -this.handleHalfDim : 0)) +\n                        'px';\n                this.barStyle.backgroundSize =\n                    '100% ' + (this.barDimension - this.handleHalfDim) + 'px';\n            }\n            else {\n                this.barStyle.backgroundPosition =\n                    offset -\n                        position +\n                        (reversed ? this.handleHalfDim : 0) +\n                        'px center';\n                this.barStyle.backgroundSize =\n                    this.barDimension - this.handleHalfDim + 'px 100%';\n            }\n        }\n    };\n    SliderComponent.prototype.getSelectionBarColor = function () {\n        if (this.range) {\n            return this.viewOptions.getSelectionBarColor(this.value, this.highValue);\n        }\n        return this.viewOptions.getSelectionBarColor(this.value);\n    };\n    SliderComponent.prototype.getPointerColor = function (pointerType) {\n        if (pointerType === PointerType.Max) {\n            return this.viewOptions.getPointerColor(this.highValue, pointerType);\n        }\n        return this.viewOptions.getPointerColor(this.value, pointerType);\n    };\n    SliderComponent.prototype.getTickColor = function (value) {\n        return this.viewOptions.getTickColor(value);\n    };\n    SliderComponent.prototype.updateCmbLabel = function () {\n        var isLabelOverlap = null;\n        if (this.viewOptions.rightToLeft) {\n            isLabelOverlap =\n                this.minLabElem.position - this.minLabElem.dimension - 10 <= this.maxLabElem.position;\n        }\n        else {\n            isLabelOverlap =\n                this.minLabElem.position + this.minLabElem.dimension + 10 >= this.maxLabElem.position;\n        }\n        if (isLabelOverlap) {\n            var lowTr = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n            var highTr = this.getDisplayValue(this.viewHighValue, LabelType.High);\n            var labelVal = this.viewOptions.rightToLeft\n                ? this.combineLabels(highTr, lowTr)\n                : this.combineLabels(lowTr, highTr);\n            this.setLabelValue(labelVal, this.cmbLabElem);\n            var pos = this.viewOptions.boundPointerLabels\n                ? Math.min(Math.max(this.selBarElem.position +\n                    this.selBarElem.dimension / 2 -\n                    this.cmbLabElem.dimension / 2, 0), this.barDimension - this.cmbLabElem.dimension)\n                : this.selBarElem.position + this.selBarElem.dimension / 2 - this.cmbLabElem.dimension / 2;\n            this.setPosition(this.cmbLabElem, pos);\n            this.cmbLabelShown = true;\n            this.hideEl(this.minLabElem);\n            this.hideEl(this.maxLabElem);\n            this.showEl(this.cmbLabElem);\n        }\n        else {\n            this.cmbLabelShown = false;\n            this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n            this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n            this.showEl(this.maxLabElem);\n            this.showEl(this.minLabElem);\n            this.hideEl(this.cmbLabElem);\n        }\n        if (this.viewOptions.autoHideLimitLabels) {\n            this.shFloorCeil();\n        }\n    };\n    SliderComponent.prototype.getDisplayValue = function (value, which) {\n        if (this.viewOptions.stepsArray && !this.viewOptions.bindIndexForStepsArray) {\n            value = this.getStepValue(value);\n        }\n        return this.translate(value, which);\n    };\n    SliderComponent.prototype.roundStep = function (value, customStep) {\n        var step = customStep ? customStep : this.step;\n        var steppedDifference = MathHelper.roundToPrecisionLimit((value - this.minValue) / step, this.precisionLimit);\n        steppedDifference = Math.round(steppedDifference) * step;\n        return MathHelper.roundToPrecisionLimit(this.minValue + steppedDifference, this.precisionLimit);\n    };\n    SliderComponent.prototype.hideEl = function (element) {\n        element.css('visibility', 'hidden');\n    };\n    SliderComponent.prototype.showEl = function (element) {\n        if (!!element.alwaysHide) {\n            return;\n        }\n        element.css('visibility', 'visible');\n    };\n    SliderComponent.prototype.setPosition = function (elem, pos) {\n        elem.position = pos;\n        if (this.viewOptions.vertical) {\n            elem.css('bottom', Math.round(pos) + 'px');\n        }\n        else {\n            elem.css('left', Math.round(pos) + 'px');\n        }\n    };\n    SliderComponent.prototype.calculateElementDimension = function (elem) {\n        var val = elem.getBoundingClientRect();\n        if (this.viewOptions.vertical) {\n            elem.dimension = (val.bottom - val.top) * this.viewOptions.scale;\n        }\n        else {\n            elem.dimension = (val.right - val.left) * this.viewOptions.scale;\n        }\n    };\n    SliderComponent.prototype.setDimension = function (elem, dim) {\n        elem.dimension = dim;\n        if (this.viewOptions.vertical) {\n            elem.css('height', Math.round(dim) + 'px');\n        }\n        else {\n            elem.css('width', Math.round(dim) + 'px');\n        }\n        return dim;\n    };\n    SliderComponent.prototype.sanitizeValue = function (val) {\n        return Math.min(Math.max(val, this.minValue), this.maxValue);\n    };\n    SliderComponent.prototype.valueToPosition = function (val) {\n        var fn = ValueHelper.linearValueToPosition;\n        if (this.viewOptions.customValueToPosition) {\n            fn = this.viewOptions.customValueToPosition;\n        }\n        else if (this.viewOptions.logScale) {\n            fn = ValueHelper.logValueToPosition;\n        }\n        val = this.sanitizeValue(val);\n        var percent = fn(val, this.minValue, this.maxValue) || 0;\n        if (this.viewOptions.rightToLeft) {\n            percent = 1 - percent;\n        }\n        return percent * this.maxPos;\n    };\n    SliderComponent.prototype.positionToValue = function (position) {\n        var percent = position / this.maxPos;\n        if (this.viewOptions.rightToLeft) {\n            percent = 1 - percent;\n        }\n        var fn = ValueHelper.linearPositionToValue;\n        if (this.viewOptions.customPositionToValue) {\n            fn = this.viewOptions.customPositionToValue;\n        }\n        else if (this.viewOptions.logScale) {\n            fn = ValueHelper.logPositionToValue;\n        }\n        return fn(percent, this.minValue, this.maxValue) || 0;\n    };\n    SliderComponent.prototype.getEventXY = function (event, targetTouchId) {\n        if (event instanceof MouseEvent) {\n            return this.viewOptions.vertical ? event.clientY : event.clientX;\n        }\n        var touchIndex = 0;\n        var touches = event.touches;\n        if (targetTouchId !== undefined) {\n            for (var i = 0; i < touches.length; i++) {\n                if (touches[i].identifier === targetTouchId) {\n                    touchIndex = i;\n                    break;\n                }\n            }\n        }\n        return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n    };\n    SliderComponent.prototype.getEventPosition = function (event, targetTouchId) {\n        var sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();\n        var sliderPos = this.viewOptions.vertical ?\n            sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n        var eventPos = 0;\n        if (this.viewOptions.vertical) {\n            eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n        }\n        else {\n            eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n        }\n        return eventPos * this.viewOptions.scale - this.handleHalfDim;\n    };\n    SliderComponent.prototype.getNearestHandle = function (event) {\n        if (!this.range) {\n            return this.minHElem;\n        }\n        var position = this.getEventPosition(event);\n        var distanceMin = Math.abs(position - this.minHElem.position);\n        var distanceMax = Math.abs(position - this.maxHElem.position);\n        if (distanceMin < distanceMax) {\n            return this.minHElem;\n        }\n        else if (distanceMin > distanceMax) {\n            return this.maxHElem;\n        }\n        else if (!this.viewOptions.rightToLeft) {\n            return position < this.minHElem.position ? this.minHElem : this.maxHElem;\n        }\n        else {\n            return position > this.minHElem.position ? this.minHElem : this.maxHElem;\n        }\n    };\n    SliderComponent.prototype.focusElement = function (el) {\n        el.focus();\n    };\n    SliderComponent.prototype.bindEvents = function () {\n        var _this = this;\n        var draggableRange = this.viewOptions.draggableRange;\n        if (!this.viewOptions.onlyBindHandles) {\n            this.selBarElem.on('mousedown', function (event) { return _this.onBarStart(draggableRange, null, event, true, true, true); });\n        }\n        if (this.viewOptions.draggableRangeOnly) {\n            this.minHElem.on('mousedown', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });\n            this.maxHElem.on('mousedown', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });\n        }\n        else {\n            this.minHElem.on('mousedown', function (event) { return _this.onStart(_this.minHElem, HandleType.Low, event, true, true); });\n            if (this.range) {\n                this.maxHElem.on('mousedown', function (event) { return _this.onStart(_this.maxHElem, HandleType.High, event, true, true); });\n            }\n            if (!this.viewOptions.onlyBindHandles) {\n                this.fullBarElem.on('mousedown', function (event) { _this.onStart(null, null, event, true, true, true); });\n                this.ticksElem.on('mousedown', function (event) { _this.onStart(null, null, event, true, true, true, true); });\n            }\n        }\n        if (!this.viewOptions.onlyBindHandles) {\n            this.selBarElem.onPassive('touchstart', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });\n        }\n        if (this.viewOptions.draggableRangeOnly) {\n            this.minHElem.onPassive('touchstart', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });\n            this.maxHElem.onPassive('touchstart', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });\n        }\n        else {\n            this.minHElem.onPassive('touchstart', function (event) { return _this.onStart(_this.minHElem, HandleType.Low, event, true, true); });\n            if (this.range) {\n                this.maxHElem.onPassive('touchstart', function (event) { return _this.onStart(_this.maxHElem, HandleType.High, event, true, true); });\n            }\n            if (!this.viewOptions.onlyBindHandles) {\n                this.fullBarElem.onPassive('touchstart', function (event) { return _this.onStart(null, null, event, true, true, true); });\n                this.ticksElem.onPassive('touchstart', function (event) { return _this.onStart(null, null, event, false, false, true, true); });\n            }\n        }\n        if (this.viewOptions.keyboardSupport) {\n            this.minHElem.on('focus', function () { return _this.onPointerFocus(_this.minHElem, HandleType.Low); });\n            if (this.range) {\n                this.maxHElem.on('focus', function () { return _this.onPointerFocus(_this.maxHElem, HandleType.High); });\n            }\n        }\n    };\n    SliderComponent.prototype.unbindEvents = function () {\n        this.minHElem.off();\n        this.maxHElem.off();\n        this.fullBarElem.off();\n        this.selBarElem.off();\n        this.ticksElem.off();\n    };\n    SliderComponent.prototype.onBarStart = function (draggableRange, pointer, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        if (draggableRange) {\n            this.onDragStart(pointer, HandleType.High, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n        }\n        else {\n            this.onStart(pointer, HandleType.Low, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n        }\n    };\n    SliderComponent.prototype.onStart = function (pointer, ref, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        var _this = this;\n        var moveEvent = '';\n        var endEvent = '';\n        if (CompatibilityHelper.isTouchEvent(event)) {\n            moveEvent = 'touchmove';\n            endEvent = 'touchend';\n        }\n        else {\n            moveEvent = 'mousemove';\n            endEvent = 'mouseup';\n        }\n        event.stopPropagation();\n        if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {\n            event.preventDefault();\n        }\n        this.calcViewDimensions();\n        if (pointer) {\n            this.tracking = ref;\n        }\n        else {\n            pointer = this.getNearestHandle(event);\n            this.tracking = pointer === this.minHElem ? HandleType.Low : HandleType.High;\n        }\n        pointer.addClass('ng5-slider-active');\n        if (this.viewOptions.keyboardSupport) {\n            this.focusElement(pointer);\n        }\n        if (bindMove) {\n            var ehMove = function (e) { return _this.dragging.active ? _this.onDragMove(pointer, e) : _this.onMove(pointer, e); };\n            if (this.onMoveUnsubscribe !== null) {\n                this.onMoveUnsubscribe();\n            }\n            this.onMoveUnsubscribe = this.renderer.listen('document', moveEvent, ehMove);\n        }\n        if (bindEnd) {\n            var ehEnd = function (e) { return _this.onEnd(e); };\n            if (this.onEndUnsubscribe !== null) {\n                this.onEndUnsubscribe();\n            }\n            this.onEndUnsubscribe = this.renderer.listen('document', endEvent, ehEnd);\n        }\n        this.userChangeStart.emit(this.getChangeContext());\n        if (CompatibilityHelper.isTouchEvent(event) && ((event)).changedTouches) {\n            if (!this.touchId) {\n                this.isDragging = true;\n                this.touchId = ((event)).changedTouches[0].identifier;\n            }\n        }\n        if (simulateImmediateMove) {\n            this.onMove(pointer, event, true);\n        }\n        if (simulateImmediateEnd) {\n            this.onEnd(event);\n        }\n    };\n    SliderComponent.prototype.onMove = function (pointer, event, fromTick) {\n        var touchForThisSlider;\n        if (CompatibilityHelper.isTouchEvent(event)) {\n            var changedTouches = ((event)).changedTouches;\n            for (var i = 0; i < changedTouches.length; i++) {\n                if (changedTouches[i].identifier === this.touchId) {\n                    touchForThisSlider = changedTouches[i];\n                    break;\n                }\n            }\n            if (!touchForThisSlider) {\n                return;\n            }\n        }\n        var newPos = this.getEventPosition(event, touchForThisSlider ? touchForThisSlider.identifier : undefined);\n        var newValue;\n        var ceilValue = this.viewOptions.rightToLeft\n            ? this.minValue\n            : this.maxValue;\n        var flrValue = this.viewOptions.rightToLeft ? this.maxValue : this.minValue;\n        if (newPos <= 0) {\n            newValue = flrValue;\n        }\n        else if (newPos >= this.maxPos) {\n            newValue = ceilValue;\n        }\n        else {\n            newValue = this.positionToValue(newPos);\n            if (fromTick && this.viewOptions.tickStep !== null) {\n                newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n            }\n            else {\n                newValue = this.roundStep(newValue);\n            }\n        }\n        this.positionTrackingHandle(newValue);\n    };\n    SliderComponent.prototype.onEnd = function (event) {\n        if (CompatibilityHelper.isTouchEvent(event)) {\n            var changedTouches = ((event)).changedTouches;\n            if (changedTouches[0].identifier !== this.touchId) {\n                return;\n            }\n        }\n        this.isDragging = false;\n        this.touchId = null;\n        if (!this.viewOptions.keyboardSupport) {\n            this.minHElem.removeClass('ng5-slider-active');\n            this.maxHElem.removeClass('ng5-slider-active');\n            this.tracking = null;\n        }\n        this.dragging.active = false;\n        if (this.onMoveUnsubscribe !== null) {\n            this.onMoveUnsubscribe();\n        }\n        if (this.onEndUnsubscribe !== null) {\n            this.onEndUnsubscribe();\n        }\n        this.userChangeEnd.emit(this.getChangeContext());\n    };\n    SliderComponent.prototype.onPointerFocus = function (pointer, ref) {\n        var _this = this;\n        this.tracking = ref;\n        pointer.on('blur', function () { return _this.onPointerBlur(pointer); });\n        pointer.on('keydown', function (event) { return _this.onKeyboardEvent(event); });\n        pointer.on('keyup', function () { return _this.onKeyUp(); });\n        this.firstKeyDown = true;\n        pointer.addClass('ng5-slider-active');\n        this.currentFocusElement = {\n            pointer: pointer,\n            ref: ref,\n        };\n    };\n    SliderComponent.prototype.onKeyUp = function () {\n        this.firstKeyDown = true;\n        this.userChangeEnd.emit(this.getChangeContext());\n    };\n    SliderComponent.prototype.onPointerBlur = function (pointer) {\n        pointer.off('blur');\n        pointer.off('keydown');\n        pointer.off('keyup');\n        pointer.removeClass('ng5-slider-active');\n        if (!this.isDragging) {\n            this.tracking = null;\n            this.currentFocusElement = null;\n        }\n    };\n    SliderComponent.prototype.getKeyActions = function (currentValue) {\n        var increaseStep = currentValue + this.step;\n        var decreaseStep = currentValue - this.step;\n        var increasePage = currentValue + this.valueRange / 10;\n        var decreasePage = currentValue - this.valueRange / 10;\n        if (this.viewOptions.reversedControls) {\n            increaseStep = currentValue - this.step;\n            decreaseStep = currentValue + this.step;\n            increasePage = currentValue - this.valueRange / 10;\n            decreasePage = currentValue + this.valueRange / 10;\n        }\n        var actions = {\n            UP: increaseStep,\n            DOWN: decreaseStep,\n            LEFT: decreaseStep,\n            RIGHT: increaseStep,\n            PAGEUP: increasePage,\n            PAGEDOWN: decreasePage,\n            HOME: this.viewOptions.reversedControls ? this.maxValue : this.minValue,\n            END: this.viewOptions.reversedControls ? this.minValue : this.maxValue,\n        };\n        if (this.viewOptions.rightToLeft) {\n            actions[\"LEFT\"] = increaseStep;\n            actions[\"RIGHT\"] = decreaseStep;\n            if (this.viewOptions.vertical) {\n                actions[\"UP\"] = decreaseStep;\n                actions[\"DOWN\"] = increaseStep;\n            }\n        }\n        return actions;\n    };\n    SliderComponent.prototype.onKeyboardEvent = function (event) {\n        var currentValue = this.getCurrentTrackingValue();\n        var keyCode = event.keyCode || event.which;\n        var keys = {\n            38: 'UP',\n            40: 'DOWN',\n            37: 'LEFT',\n            39: 'RIGHT',\n            33: 'PAGEUP',\n            34: 'PAGEDOWN',\n            36: 'HOME',\n            35: 'END',\n        };\n        var actions = this.getKeyActions(currentValue);\n        var key = keys[keyCode];\n        var action = actions[key];\n        if (action == null || this.tracking === null) {\n            return;\n        }\n        event.preventDefault();\n        if (this.firstKeyDown) {\n            this.firstKeyDown = false;\n            this.userChangeStart.emit(this.getChangeContext());\n        }\n        var newValue = this.roundStep(this.sanitizeValue(action));\n        if (!this.viewOptions.draggableRangeOnly) {\n            this.positionTrackingHandle(newValue);\n        }\n        else {\n            var difference = this.viewHighValue - this.viewLowValue;\n            var newMinValue = void 0;\n            var newMaxValue = void 0;\n            if (this.tracking === HandleType.Low) {\n                newMinValue = newValue;\n                newMaxValue = newValue + difference;\n                if (newMaxValue > this.maxValue) {\n                    newMaxValue = this.maxValue;\n                    newMinValue = newMaxValue - difference;\n                }\n            }\n            else {\n                newMaxValue = newValue;\n                newMinValue = newValue - difference;\n                if (newMinValue < this.minValue) {\n                    newMinValue = this.minValue;\n                    newMaxValue = newMinValue + difference;\n                }\n            }\n            this.positionTrackingBar(newMinValue, newMaxValue);\n        }\n    };\n    SliderComponent.prototype.onDragStart = function (pointer, ref, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        var position = this.getEventPosition(event);\n        this.dragging = new Dragging();\n        this.dragging.active = true;\n        this.dragging.value = this.positionToValue(position);\n        this.dragging.difference = this.viewHighValue - this.viewLowValue;\n        this.dragging.lowLimit = this.viewOptions.rightToLeft\n            ? this.minHElem.position - position\n            : position - this.minHElem.position;\n        this.dragging.highLimit = this.viewOptions.rightToLeft\n            ? position - this.maxHElem.position\n            : this.maxHElem.position - position;\n        this.onStart(pointer, ref, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n    };\n    SliderComponent.prototype.getMinValue = function (newPos, outOfBounds, isAbove) {\n        var isRTL = this.viewOptions.rightToLeft;\n        var value = null;\n        if (outOfBounds) {\n            if (isAbove) {\n                value = isRTL\n                    ? this.minValue\n                    : this.maxValue - this.dragging.difference;\n            }\n            else {\n                value = isRTL\n                    ? this.maxValue - this.dragging.difference\n                    : this.minValue;\n            }\n        }\n        else {\n            value = isRTL\n                ? this.positionToValue(newPos + this.dragging.lowLimit)\n                : this.positionToValue(newPos - this.dragging.lowLimit);\n        }\n        return this.roundStep(value);\n    };\n    SliderComponent.prototype.getMaxValue = function (newPos, outOfBounds, isAbove) {\n        var isRTL = this.viewOptions.rightToLeft;\n        var value = null;\n        if (outOfBounds) {\n            if (isAbove) {\n                value = isRTL\n                    ? this.minValue + this.dragging.difference\n                    : this.maxValue;\n            }\n            else {\n                value = isRTL\n                    ? this.maxValue\n                    : this.minValue + this.dragging.difference;\n            }\n        }\n        else {\n            if (isRTL) {\n                value =\n                    this.positionToValue(newPos + this.dragging.lowLimit) +\n                        this.dragging.difference;\n            }\n            else {\n                value =\n                    this.positionToValue(newPos - this.dragging.lowLimit) +\n                        this.dragging.difference;\n            }\n        }\n        return this.roundStep(value);\n    };\n    SliderComponent.prototype.onDragMove = function (pointer, event) {\n        var newPos = this.getEventPosition(event);\n        var ceilLimit, flrLimit, flrHElem, ceilHElem;\n        if (this.viewOptions.rightToLeft) {\n            ceilLimit = this.dragging.lowLimit;\n            flrLimit = this.dragging.highLimit;\n            flrHElem = this.maxHElem;\n            ceilHElem = this.minHElem;\n        }\n        else {\n            ceilLimit = this.dragging.highLimit;\n            flrLimit = this.dragging.lowLimit;\n            flrHElem = this.minHElem;\n            ceilHElem = this.maxHElem;\n        }\n        var isUnderFlrLimit = newPos <= flrLimit;\n        var isOverCeilLimit = newPos >= this.maxPos - ceilLimit;\n        var newMinValue;\n        var newMaxValue;\n        if (isUnderFlrLimit) {\n            if (flrHElem.position === 0) {\n                return;\n            }\n            newMinValue = this.getMinValue(newPos, true, false);\n            newMaxValue = this.getMaxValue(newPos, true, false);\n        }\n        else if (isOverCeilLimit) {\n            if (ceilHElem.position === this.maxPos) {\n                return;\n            }\n            newMaxValue = this.getMaxValue(newPos, true, true);\n            newMinValue = this.getMinValue(newPos, true, true);\n        }\n        else {\n            newMinValue = this.getMinValue(newPos, false, false);\n            newMaxValue = this.getMaxValue(newPos, false, false);\n        }\n        this.positionTrackingBar(newMinValue, newMaxValue);\n    };\n    SliderComponent.prototype.positionTrackingBar = function (newMinValue, newMaxValue) {\n        if (this.viewOptions.minLimit != null &&\n            newMinValue < this.viewOptions.minLimit) {\n            newMinValue = this.viewOptions.minLimit;\n            newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.precisionLimit);\n        }\n        if (this.viewOptions.maxLimit != null &&\n            newMaxValue > this.viewOptions.maxLimit) {\n            newMaxValue = this.viewOptions.maxLimit;\n            newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.precisionLimit);\n        }\n        this.viewLowValue = newMinValue;\n        this.viewHighValue = newMaxValue;\n        this.applyLowValue();\n        if (this.range) {\n            this.applyHighValue();\n        }\n        this.applyModel(true);\n        this.updateHandles(HandleType.Low, this.valueToPosition(newMinValue));\n        this.updateHandles(HandleType.High, this.valueToPosition(newMaxValue));\n    };\n    SliderComponent.prototype.positionTrackingHandle = function (newValue) {\n        var valueChanged = false;\n        newValue = this.applyMinMaxLimit(newValue);\n        if (this.range) {\n            if (this.viewOptions.pushRange) {\n                newValue = this.applyPushRange(newValue);\n                valueChanged = true;\n            }\n            else {\n                if (this.viewOptions.noSwitching) {\n                    if (this.tracking === HandleType.Low && newValue > this.viewHighValue) {\n                        newValue = this.applyMinMaxRange(this.viewHighValue);\n                    }\n                    else if (this.tracking === HandleType.High &&\n                        newValue < this.viewLowValue) {\n                        newValue = this.applyMinMaxRange(this.viewLowValue);\n                    }\n                }\n                newValue = this.applyMinMaxRange(newValue);\n                if (this.tracking === HandleType.Low && newValue > this.viewHighValue) {\n                    this.viewLowValue = this.viewHighValue;\n                    this.applyLowValue();\n                    this.applyModel(false);\n                    this.updateHandles(HandleType.Low, this.maxHElem.position);\n                    this.updateAriaAttributes();\n                    this.tracking = HandleType.High;\n                    this.minHElem.removeClass('ng5-slider-active');\n                    this.maxHElem.addClass('ng5-slider-active');\n                    if (this.viewOptions.keyboardSupport) {\n                        this.focusElement(this.maxHElem);\n                    }\n                    valueChanged = true;\n                }\n                else if (this.tracking === HandleType.High &&\n                    newValue < this.viewLowValue) {\n                    this.viewHighValue = this.viewLowValue;\n                    this.applyHighValue();\n                    this.applyModel(false);\n                    this.updateHandles(HandleType.High, this.minHElem.position);\n                    this.updateAriaAttributes();\n                    this.tracking = HandleType.Low;\n                    this.maxHElem.removeClass('ng5-slider-active');\n                    this.minHElem.addClass('ng5-slider-active');\n                    if (this.viewOptions.keyboardSupport) {\n                        this.focusElement(this.minHElem);\n                    }\n                    valueChanged = true;\n                }\n            }\n        }\n        if (this.getCurrentTrackingValue() !== newValue) {\n            if (this.tracking === HandleType.Low) {\n                this.viewLowValue = newValue;\n                this.applyLowValue();\n            }\n            else {\n                this.viewHighValue = newValue;\n                this.applyHighValue();\n            }\n            this.applyModel(false);\n            this.updateHandles(this.tracking, this.valueToPosition(newValue));\n            this.updateAriaAttributes();\n            valueChanged = true;\n        }\n        if (valueChanged) {\n            this.applyModel(true);\n        }\n    };\n    SliderComponent.prototype.applyMinMaxLimit = function (newValue) {\n        if (this.viewOptions.minLimit != null && newValue < this.viewOptions.minLimit) {\n            return this.viewOptions.minLimit;\n        }\n        if (this.viewOptions.maxLimit != null && newValue > this.viewOptions.maxLimit) {\n            return this.viewOptions.maxLimit;\n        }\n        return newValue;\n    };\n    SliderComponent.prototype.applyMinMaxRange = function (newValue) {\n        var oppositeValue = this.tracking === HandleType.Low ? this.viewHighValue : this.viewLowValue;\n        var difference = Math.abs(newValue - oppositeValue);\n        if (this.viewOptions.minRange != null) {\n            if (difference < this.viewOptions.minRange) {\n                if (this.tracking === HandleType.Low) {\n                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.precisionLimit);\n                }\n                else {\n                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.precisionLimit);\n                }\n            }\n        }\n        if (this.viewOptions.maxRange != null) {\n            if (difference > this.viewOptions.maxRange) {\n                if (this.tracking === HandleType.Low) {\n                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.precisionLimit);\n                }\n                else {\n                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.precisionLimit);\n                }\n            }\n        }\n        return newValue;\n    };\n    SliderComponent.prototype.applyPushRange = function (newValue) {\n        var difference = this.tracking === HandleType.Low\n            ? this.viewHighValue - newValue\n            : newValue - this.viewLowValue;\n        var minRange = this.viewOptions.minRange !== null\n            ? this.viewOptions.minRange\n            : this.viewOptions.step;\n        var maxRange = this.viewOptions.maxRange;\n        if (difference < minRange) {\n            if (this.tracking === HandleType.Low) {\n                this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.maxValue), this.precisionLimit);\n                newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.precisionLimit);\n                this.applyHighValue();\n                this.updateHandles(HandleType.High, this.valueToPosition(this.viewHighValue));\n            }\n            else {\n                this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.minValue), this.precisionLimit);\n                newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.precisionLimit);\n                this.applyLowValue();\n                this.updateHandles(HandleType.Low, this.valueToPosition(this.viewLowValue));\n            }\n            this.updateAriaAttributes();\n        }\n        else if (maxRange !== null && difference > maxRange) {\n            if (this.tracking === HandleType.Low) {\n                this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.precisionLimit);\n                this.applyHighValue();\n                this.updateHandles(HandleType.High, this.valueToPosition(this.viewHighValue));\n            }\n            else {\n                this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.precisionLimit);\n                this.applyLowValue();\n                this.updateHandles(HandleType.Low, this.valueToPosition(this.viewLowValue));\n            }\n            this.updateAriaAttributes();\n        }\n        return newValue;\n    };\n    SliderComponent.prototype.applyModel = function (callUserChange) {\n        this.valueChange.emit(this.value);\n        this.highValueChange.emit(this.highValue);\n        if (callUserChange) {\n            this.userChange.emit(this.getChangeContext());\n        }\n        if (this.onChangeCallback) {\n            if (this.range) {\n                this.onChangeCallback([this.value, this.highValue]);\n            }\n            else {\n                this.onChangeCallback(this.value);\n            }\n        }\n        if (this.onTouchedCallback) {\n            if (this.range) {\n                this.onTouchedCallback([this.value, this.highValue]);\n            }\n            else {\n                this.onTouchedCallback(this.value);\n            }\n        }\n    };\n    SliderComponent.prototype.getChangeContext = function () {\n        var changeContext = new ChangeContext();\n        changeContext.pointerType = this.tracking === HandleType.Low ? PointerType.Min : PointerType.Max;\n        changeContext.value = this.value;\n        changeContext.highValue = this.highValue;\n        return changeContext;\n    };\n    return SliderComponent;\n}());\nvar TooltipWrapperComponent = /*@__PURE__*/ (function () {\n    function TooltipWrapperComponent() {\n    }\n    return TooltipWrapperComponent;\n}());\nvar Ng5SliderModule = /*@__PURE__*/ (function () {\n    function Ng5SliderModule() {\n    }\n    return Ng5SliderModule;\n}());\nexport { Ng5SliderModule, ChangeContext, PointerType, LabelType, Options, JqLiteWrapper as ɵo, CeilLabDirective as ɵi, CmbLabDirective as ɵl, FlrLabDirective as ɵh, FullBarDirective as ɵd, LeftOutSelDirective as ɵc, MaxHDirective as ɵg, MaxLabDirective as ɵk, MinHDirective as ɵf, MinLabDirective as ɵj, RightOutSelDirective as ɵb, SelBarDirective as ɵe, SliderComponent as ɵn, SliderElement as ɵa, TicksDirective as ɵm, TooltipWrapperComponent as ɵp };\n//# sourceMappingURL=ng5-slider.js.map\n",null]}